请不要将函数定义或变量声明放到头文件中(应该是针对全局的而言，一个类作用域内的不会出现啥问题)

## 静态持续性、外部链接性

1. 单定义规则

在每个使用外部变量的文件中，都必须声明它；单定义规则指出，变量只能有一次定义。C++提供了两种变量声明。一种是**定义声明**，它给变量分配存储空间；另一种是**引用声明**，它不给变量分配存储空间，因为它引用已有的变量。

> 引用声明使用关键字`extern`，且不进行初始化。

## 运算符重载限制

下面的运算符只能通过成员函数进行重载：

- `=`：赋值运算符
- `()`：函数调用运算符
- `[]`：下标运算符
- `->`：通过指针访问类成员的运算符

## 类继承

如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。

经常在基类中将派生类会重新定义的方法声明为虚方法。基类声明了一个虚析构函数，是为了确保释放派生对象时，按正确的顺序调用析构函数。

编译器对非虚方法使用静态联编。

## 访问基类的方法

使用包含时将使用对象名来调用方法，而使用私有继承时将使用类名和作用域解析运算符来调用方法。

通常，应使用包含来建立`has-a`关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承。

## 虚基类构造规则

> 如果类有间接虚基类，则除非只需使用该虚基类的默认构造函数，否则必须显式地调用该虚基类的某个构造函数。

## C++建议

> 声明一个`pure virtual`函数的目的是为了让继承类只继承函数接口。
> 声明非纯虚函数的目的是让继承类继承该函数的接口和缺省实现。
> 声明非虚函数的目的是为了令继承类继承函数的接口及一份强制性实现。

我们可以轻易做到“提供缺省实现给继承类，但除非它们明确要求否则免谈”。此伎俩在于切断“virtual函数接口”和其“缺省实现”之间的连接。

```c++
class Airplane {
public:
    virtual void fly(const Airport& destination) = 0;
protected:
    void defaultFly(const Airport& destination);
};
void Airplane::defaultFly(const Airport& destination) {
    // default action
}

class ModelA : public Airplane {
public:
    virtual void fly(const Airport& destination) { Airplane::fly(destination); }
};

class ModelB : public Airplane {
public:
    // 此时生成ModelB对象，调用fly接口，将不会出现问题，
    // 因为其没有采用基类提供的缺省实现
    virtual void fly(const Airport& destination) {  }
};
```

## 继承与面向对象设计

> 绝不重新定义继承而来的non-virtual函数。

# 大规模C++程序设计

> Use-In-The-Interface
> 
> 如果在声明一个函数时提到某个类型，那么就是在该函数的接口中使用了该类型。
> 
> 如果在一个类的（公共）成员函数的接口中使用了某种类型，那么就是在这个类的（公共）接口中使用了该类型。

> Use-In-The-Implementation
> 
> 如果在某函数的定义中提到了某类型，那么在这个函数的实现中就使用了该类型。
> 
> 如果一个类型
> 
> 1. 被用在某个类的一个成员函数中
> 2. 在某个类的一个数据成员的声明中被提到
> 3. 是某个类的一个私有基类
> 
> 那么这个类的实现中就使用了这个类型。

<center>

|名称|含义|
|---|---|
|Uses|该类有一个成员函数命名了该类型|
|HasA|该类嵌入了该类型的一个实例|
|HoldsA|该类把一个指针（或引用）嵌入了该类型|
|WasA|该类私有继承于该类型|

</center>

## 继承与分层

> 如果某个类在它的实现中实质地使用了某个类型，则该类分层于该类型之上。

